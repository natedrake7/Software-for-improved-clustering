Λαμπρόπουλος Κωνσταντίνος ΑΜ: 1115201800092
Γκέργκη Δημήτρης ΑΜ: 1115201800029

Στην εργασία αυτή μας ζητήθηκε να υλοποιήσουμε 2 αλγορίθμους προσεγγιστικής αναζήτησης με την χρήση γράφων.
Ειδικότερα μας ζητήθηκε η υλοποίηση των αλγορίθμων: Graph Nearest Neighbor Search(GNNS) και Generic Search On Graph με Monotonic Relative Neighborhood Graphs (MRNG) ως ευρετήριο.
Ο σκόπος και των δύο αλγορίθμων είναι να βρουν προσεγγιστικά (σε πολύ λιγότερο χρόνο από τον Brute Force αλγόριθμο ) τον πλησιέστερο γείτονα δεδομένου ενός σημείο στον χώρο (Query Point) R^d.


Ο κατάλογος του κώδικα είναι:

	|-Graph----graph.cpp
	|	    |--graph.hpp
	|	  
	|
	|-Data----input.dat
	|	   |--query.dat
	|
Project     
	|
	|
    |-------graph_search.cpp
    |     |-graph_search.hpp
    |
	|-LSH----hash.cpp
     	      |--hash.hpp
     	      |--lsh.cpp
     	      |--lsh.hpp
     	      |--misc.cpp
     	      |--misc.hpp



Αρχικά το directory LSH περιέχει την υλοποίηση του LSH από την προηγούμενη εργασία μοντελοποιημένη ως προς τις ανάγκες της 2ης εργασίας.
Περιέχει επίσης κάποιες βοηθητικές συναρτήσεις ,όπως η συνάρτηση που δεδομένου των αποτελεσμάτων ενός αλγορίθμου παράγει το αντίστοιχο output file,
οι συναρτήσεις error checking που ελέγχουν αν τα νέα input files που θέλει να εισάγει ο χρήστης υπάρχουν ως αρχεία.Επίσης περιέχει συναρτήσεις για να διαβάσει
σωστά το input από την γραμμή εντολών και κάποιες για τον υπολογισμό της p-norm.Τέλος περιέχει τον brute force αλγόριθμο ο οποίος συγκρίνει ένα query point με όλα τα
υπόλοιπα σημεία και επιστρέφει τα N κοντινότερα.

Το directory Data περιέχει τα αρχεία με τα δεδομένα της εργασίας.

To directory Graph περιέχει μία κλάση για την υλοποίηση των γράφων.Αρχικά η κλάση περιέχει ως μεταβλητή έναν πίνακα απο GraphPoints
όπου κάθε Graph Point αποτελείται από μία εικόνα σε μορφή διανύσματος,την απόσταση του από τον πιθάνο γείτονα την δεδομένη στιγμή,
το μοναδικό αναγνωριστικό του ID,αν έχει γίνει επέκταση προς αυτό το σημείο και τους γείτονές του.


I  ) Η αρχικοποίηση του γράφου με τον αλγόριθμο GNNS γίνεται ως εξής: 

		1) Αρχικά αρχικοποιούμε τον αλγόριθμο LSH και κάνουμε hash όλα τις εικόνες.
		2) Μετά για κάθε ένα σημείο βρίσκουμε (αν υπάρχουν) με βάση τον αλγόριθμο LSH τους k πιο κοντινούς γείτονες
		   και τους θέτουμε ως τους γείτονες του σημείου στον γράφο.
		3) Έπειτα γίνεται ένας έλεγχος αν όλα τα σημεία έχουν γείτονες ,αν όχι το πρόγραμμα βγάζει error message και τερματίζει.

		Ο αλγόριθμος GNNS αρχικά επιλέγει ισοπίθανα ένα τυχαίο σημείο του γράφου για κάθε Random Restart,για το οποίο ακολουθείται
		η εξής διαδικασία:
		1) Για 10 greedy steps βρίσκει τους πλησιέστερους γείτονες του σημείου με την συνάρτηση GetClosestNeighbors.
		2) Η συνάρτηση αυτή ελέγχει αρχικά αν ένα σημείο έχει γείτονες ,αν όχι επιστρέφει -1 ώστε να περάσουμε στο επόμενο
		   τυχαίο σημείο.Αν έχει γείτονες ελέγχει αν είναι expanded ένας γείτονας πρώτα,αν ναι προσπερνάται,αν όχι υπολογίζεται
		   η απόσταση του query point με τον γείτονα αυτόν,προστίθεται στα expansion points όποτε γίνεται και expanded το σημείο
		   ώστε να μην ξανα ελεγχθεί για αυτό το query point.Τέλος ελέγχεται αν όλοι οι γείτονες του current point μας ήταν ήδη expanded ώστε 
		   να προχωρήσουμε απευθείας στο επόμενο τυχαίο σημείο,αν δεν ισχύει αυτό όμως ,επιστρέφεται ο κοντινότερος γείτονας ώστε να επαναληφθεί η ίδια διαδικασία
		   για αυτόν.Ο αλγόριθμος για ένα query point τερματίζει όταν εκτελεστούν k random restarts και για κάθε random restart l greedy steps.
		   Στο τέλος γίνεται sort ο πίνακας με τους προσσεγιστικούς γείτονες του query point,και επιστρέφονται οι N κοντινότεροι.

II ) Όσον αφορά την Search on Graph ισχύουν τα παρακάτω βήματα:
		Η αρχικοποίηση του γράφου με τον αλγόριθμο MRNG γίνεται ως εξής:
		1) Αρχικά κατασκευαζουμέ μια εικόνας της οντοτήτας γράφου επιλέγοντας τον κατάλληλο overload constructor (διχως lsh), απεικονίζοντας τα σημεία στο επιπέδο
		   χωρίς καμία απολυτώς ακμή μεταξύ δύο σημειών
		2) Έπειτα για αυτό το σύνολο σημειών στο επιπέδο καλείται η μέθοδος της κλάσης MRNG: 
			1.1) Για κάθε σημείο του επιπέδου (p) , αρχικοποιούμε μια λίστα (Rp) των υπολοιπών σημείων με κριτηρίο την αποστασή που έχουν απο το σημείο αυτό 
				 (σε αύξουσα σειρά η ταξινομήση) (brute force method)
			1.2) Επιλέγουμε το πρωτο στοιχείο της λίστας (το κοντινότερο του) και αρχικοποιούμε την λίστα των γειτονών του εξεταζόμενου σημείου (Lp) , από την προηγούμενη 
				 λίστα διαγράφουμε το στοιχείο
				 εισήχθει στην λίστα γειτόνων ώστε να λάβουμε το σετ (Rp-Lp) το οποίο είναι το σετ των υποψήφιων γειτονών.
			1.3) Εξετάζουμε για κάθε υποψηφίο γείτονα (r) τις αποστάσεις που δημιουργουνταί για κάθε επιβεβαιωμένο γείτονα (t) της λίστας γειτόνων (Lp).
			1.4) Έαν για κάθε γείτονα (t) , η απόσταση μεταξύ του εξεταζόμενου σημείου (p) και του υποψηφιού γείτονα (r) που έχουμε επιλέξει δεν είναι ποτέ η μεγαλύτερη από 
			     τις άλλες δυο αποστάσεις (rt & pt) τότε πληρείται η συνθήκη γειτνίασης και ο υποψηφιος γείτονας (r) προστίθεται στην λίστα γειτόνων του σημείου που ελέγχουμε (p).
			1.5) Εάν δεν πληρείται η παραπανώ συνθήκη τότε προχωράμε στον επόμενο υποψηφίο γείτονα εκτελώντας τους ίδιους ελέγχους του 1.4
			1.6) Άφου τελειώσουμε την εξέταση όλων των υποψηφιων γειτόνων (r) του (p) , προχωράμε στην εύρεση της λιστας γειτνίασης του επίμενου σήμειου του γράφου (p), 
				 αρχικοποιώντας εκ νέου της προήγουμενες λίστες και επαναλαμβάνουμε όλα τα προηγούμενα βήματα.
		3) Με αυτο το τρόπο λαμβάνουμε εναν MRNG γράφο , ο οποιός θα χρησιμοποιηθεί ως ευρετήριο στην generic search on graph (απο το uploaded paper του project 2) 
			3.1) Δίνουμε ως ορίσματα στην search on graph το query point , ένα vector of tuples που θα αποθηκευόνται οι γείτονες που ζητούνται μαζί με τις αποστάσεις απο 
				 το query point του καθενός, ο MRNG γράφος , ένας ακέραιος που είναι ο αριθμός γειτονών που ζητούνται για το query point (n )(πρέπει να είναι μικρότερος η ίσος 
				 του αριθμού μέγιστου πλήθος δεξαμενής υποψηφίων) και ο αριθμός μέγιστου πλήθος δεξαμενής υποψηφίων (l) με default τιμή το 20.
			3.2) Επιλέγουμε τυχαία ισοπίθανα ένα σημείο του γράφου ως starting point.
			3.3) Aρχικοποιούμε την poolOfCandidates (δεξαμενή υποψήφιων) με το startingPoint και αρχικοποιούμε και ένα set ονόματι checkedNodes που θα αποθηκεύονται όλα τα 
			     checked σημεία του αλγόριθμου 
			3.4) Βρίσκουμε την θέση του πρώτου μη εξετασμένου στοιχείου στην δεξαμενή υποψηφίων , κρατάμε την θέση και πρσθέτουμε του σήμειου αυτού του γράφου στην checked nodes (εξετασμένο)
				 Σε περίπτωση που δεν βρεθεί μη εξετασμένο σημείο στην δεξαμενή , τερματίζεται ο αλγόριθμος και επιστρέφονται τα πρώτα n σήμεια απο την δεξαμενή (l) και γίνονται τα γειτονικά 
				 σημεία του query point προσεγγιστικά.
			3.5) Έπειτα κάθε γείτονας του μαρκαρισμένου σημείου που δεν είναι μαρκαρισμένος (είτε θα υπάρχει μέσα στην δεξαμενή υποψηφίων ήδη , είτε θα έχει αποκλειστεί στο resize βήμα 
				 διότι υπάρχουν l κοντινότερα σημεία στο query point) καταχωρείται στην δεξαμενή υποψήφιων.
			3.6) Γίνεται ταξινομήση της δεξαμενής έπειτα απο την προσθήκη των σημείων του βήματος 3.5 σε αύξουσα σείρα της απόστασης απο το query point.
			3.7) Γίνεται αλλαγή μεγέθους της δεξαμενής ξανά σε l σε περίπτωση που το μεγέθος έπειτα απο τις προσθήκες του βήματος 3.5 είχε υπερβεί την τιμη l. Με αυτό τον τρόπο σε κάθε 
				 επανάληψη διατηρούμε τα l κοντινότερα σημεία του επιπέδου προς το query point μας, επαναλαμβάνουμε τα βήματα 3.4 ως 3.7


Οι παραπανώ δύο αλγόριθμοι βρίσκοντα στο αρχείο της graph_search.cpp μέσα στην main function του προγράμματος, οπού η main αρχικοποιεί τις απαραίτητες δομές δεδομένων, καλείται η GetArgs που
εξετάζει με ακρίβεια όλα τους παραμέτρους που τυχων καταχώρησε ο χρήστης κατα την εκτέλεση, γίνεται αρχικιποιήση της οντότητας του γράφου με βάση την μέθοδο που επιλέχθηκε (1 για GNNS 
2 για Search on Graph με MRNG). Καλούνται έπειτα οι αντίστοιχοι προσεγγιστικοί αλγορίθμοι , καλείται και ο Βruteforce αλγόριθμος για σύγκριση αποτελεσμάτων και στην συνέχεια γίνεται η
καταγραφή αυτών στο Output file.
	 
Το output file πληρεί τις προδιαγραφές της εκφώνησης και αναγράφει τα αποτελέσματα και του Bruteforce και των προσεγγιστικών αλγορίθμων , όπως επίσης και τον μέσο χρόνο για 
κάθε query point και τον MAF (μέγιστο κλάσμα προσέγγισης).

Command 'make' instructions:
 1) 'make graph' στο terminal για να παραχθεί το εκτελέσιμο αρχείο 'graph_search.o'
 2) 'make clean' για την διαγραφή του παραγόμενου εκτελέσιμου αρχείου
 

Running commands (after make command):
 Default εντολή με GNNS: 
  ./graph_search -d ./Data/input.dat -q ./Data/query.dat -o gnns.txt -m 1

 Default εντολή με Searcn On Graph (MRNG)
  ./graph_search -d ./Data/input.dat -q ./Data/query.dat -o mrng.txt -m 2


Σύγκριση Αποτελεσμάτων εκτέλεσης των αλγορίθμων: LSH,HyperCube,GNNS,MRNG.

Συγκρίνοντας τα αποτελέσματα των 4 αλγορίθμων σε dataset μεγέθους 5000 εικόνων(τα αντίστοιχα output files βρίσκονται στο directory Outputs) μπορούμε να εξάγουμε κάποια συμπεράσματα.
Αρχικά παρατηρούμε πως οι αλγόριθμοι Locality-Sensitive-Hashing (LSH), Hypercube και Graph Nearest Neighbor Search(GNNS) είναι είναι πολύ πιο αποδοτικοί ως προς την αρχική κατασκευή
,όπου για αυτούς χρειάστηκε χρόνος μερικών δευτερολέπτων ,ενώ ο αλγόριθμος Monotonic-Relative-Neighborhood-Graph (MRNG) χρειάστηκε περίπου 1 ώρα και 15 λεπτά για την αρχικοποίηση του. 
Όμως παρατηρώντας τους χρόνους εκτέλεσης φαίνεται πως οι αλγόριθμοι βασισμένοι σε γράφους (GNNS,MRNG) είναι αρκετά πιο αποδοτικοί χρονικά ,παράγοντας παρόμοι ή και καλύτερα αποτελέσματα.

Ειδικότερα παρατηρώντας τους χρόνους του Hypercube βλέπουμε πως κυμαίνονται από 8.56632ms - 32.06ms με το Maximum-Approximation-Factor (MAF) να κυμαίνεται 1-1.25383.Τα αποτελέσματα αυτά είναι
ήδη αποδεκτά μιάς και γίνεται μια εξαιρετικά καλή προσέγγιση των πλησιέστερων γειτόνων ,σε χρόνους του 1/3 και παρακάτω από τον αλγόριθμο Brute Force.Παρατηρώντας τον αλγόριθμο LSH βλέπουμε 
καλύτερη χρονική απόδοση ,με χρόνους από 8.09473ms-15.5755ms ,που σίγουρα αποτελούν βελτίωση συγκριτικά με τους χρόνους του Hypercube ,και MAF από 1.00868-1.78787,το οποίο δείχνει μία απόκλιση
στον υπολογισμό των προσεγγιστικών αποστάσεων.

Έπειτα ο αλγόριθμος GNNS ο οποίος χρησιμοποιεί τον αλγόριθμο LSH για την κατασκευή του γράφου έχει χρόνους 3.21178ms-5.92204ms,οι οποίοι είναι μία σημαντική βελτίωση συγκριτικά και 
με τον Hypercube αλλά και με τον LSH,αφού ο χειρότερος χρόνος του GNNS είναι καλύτερος από τον καλύτερο χρόνο του LSH.Το MAF του GNNS κυμαίνεται στις τιμές 1-1.46173,το οποίο δείχνει μια βελτίωση 
σε σχέση με τον LSH αλλά μία απόκλιση από τον Hypercube.

Τέλος ο αλγόριθμος MRNG έχει χρόνους 3.41332ms-6.30551ms και MAF 1 σε όλα τα query points.Αυτό σημαίνει πρακτικά ότι χρονικά είναι ελάχιστα χειρότερος του GNNS (το οποίο μπορεί οφειλεται σε πολλαπλούς 
παράγοντες που να μην σχετίζονται με τον αλγόριθμο,όπως load του επεξεργαστή τη δεδομένη στιγμή) και παράγει τις πραγματικές αποστάσεις των σημείων ως προς το query point,άρα βρίσκει και τους πραγματικούς πλησιέστερους γείτονες.


Συγκρίνοντας και τους 4 αλγορίθμους φαίνονται πως όλοι οι αλγόριθμοι υπερτερούν χρονικά του Brute Force Algorithm κατά πολύ,ειδικά οι Graph Based αλγόριθμοι,που είναι σχεδόν 20 φορές πιο γρήγοροι.
Ως προς την προσέγγιση των αποστάσεων των γειτόνων,παρατηρούμε πως ο MRNG βρίσκει τις πραγματικές,χρειάζεται όμως πολύ χρόνο ώστε να χτίσει τον γράφο,ενώ οι υπόλοιποι προσεγγίζουν αρκετά ικανοποιητικά τις πραγματικές 
αποστάσεις με πολύ μικρότερο κόστος κατασκευής.Συνεπώς σε αρκετά μεγαλύτερα Datasets,ενώ ο MRNG θα προσεγγίσει με απόλυτη ακρίβεια τους πραγματικούς γείτονες ενός query point,έχει πολύ μεγαλύτερη χρονική από όλους τους υπόλοιπους αλγορίθμους,ως προς την κατασκευή του.
Από την άλλη ο GNNS που θα μικρότερη χρονική πολυπλοκότητα κατασκευής ,θα έχει απόκλιση ως προς την προσέγγιση των γειτόνων ενός query point ,και οι αλγόριθμοι LSH και Hypercube που είναι οι πιο γρήγοροι ως
προς την κατασκευή,ο ένας έχει μεγαλύτερες αποκλίσεις ως προς την προσέγγιση των γειτόνων,και άλλος χρονικά.Τελικά συμπεραίνουμε πως ο κάθε αλγόριθμος παρουσιάζει κάποια θετικά και κάποια αρνητικά,όπου ανάλογα
τις ανάγκες της εκάστοτε υλοποίησης ,η βέλιστη επιλογή διαφέρει.
